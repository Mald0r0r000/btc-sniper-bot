"""
Historical Signal Backtester
Uses real signals from the Gist to run backtests with the trade simulator
"""

import sys
import os
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

import requests
import json
from datetime import datetime, timezone
from typing import Dict, List, Optional

from backtest.data_provider import DataProvider
from backtest.trade_simulator import TradeSimulator, SimulatorConfig
from backtest.metrics import MetricsCalculator, BacktestMetrics

from smart_entry import SmartEntryAnalyzer, EntryStrategy
from adaptive_leverage import AdaptiveLeverageCalculator


class HistoricalSignalBacktester:
    """
    Backtest using real signals stored in the GitHub Gist.
    This uses the actual signals generated by DecisionEngineV2 in production.
    """
    
    def __init__(
        self,
        gist_id: str = "b9289f1d093ddfdf94ed0b75eb8e0111",
        initial_capital: float = 10000.0,
        leverage: int = 23,
        position_size_pct: float = 10.0
    ):
        self.gist_id = gist_id
        self.data_provider = DataProvider()
        
        config = SimulatorConfig(
            initial_capital=initial_capital,
            leverage=leverage,
            position_size_pct=position_size_pct
        )
        self.trade_simulator = TradeSimulator(config)
        self.metrics_calculator = MetricsCalculator(initial_capital=initial_capital)
        
        # R&D Modules
        self.smart_entry_analyzer = SmartEntryAnalyzer()
        self.adaptive_leverage = AdaptiveLeverageCalculator()
        
    def fetch_signals_from_gist(self) -> List[Dict]:
        """Fetch signals from GitHub Gist"""
        print("\nðŸ“¡ Fetching signals from Gist...")
        
        try:
            url = f"https://api.github.com/gists/{self.gist_id}"
            response = requests.get(url, timeout=30)
            response.raise_for_status()
            
            gist_data = response.json()
            files = gist_data.get('files', {})
            
            signals = []
            if 'btc_signals_history.json' in files:
                content = json.loads(files['btc_signals_history.json']['content'])
                signals = content.get('signals', [])
            
            print(f"   âœ… Fetched {len(signals)} signals")
            return signals
            
        except Exception as e:
            print(f"   âŒ Error fetching Gist: {e}")
            return []
    
    def run(self, min_confidence: float = 65.0) -> BacktestMetrics:
        """
        Run backtest using historical signals from Gist.
        
        Args:
            min_confidence: Minimum confidence threshold to include signals
            
        Returns:
            BacktestMetrics with results
        """
        print("\n" + "=" * 65)
        print("       BACKTEST WITH REAL HISTORICAL SIGNALS")
        print("=" * 65)
        
        print(f"\nðŸ’° Initial Capital: ${self.trade_simulator.config.initial_capital:,.2f}")
        print(f"âš¡ Leverage: {self.trade_simulator.config.leverage}x")
        print(f"ðŸŽ¯ Min Confidence: {min_confidence}%")
        
        # Step 1: Fetch signals from Gist
        print("\n" + "-" * 40)
        print("STEP 1: Loading Historical Signals")
        print("-" * 40)
        
        all_signals = self.fetch_signals_from_gist()
        
        if not all_signals:
            print("âŒ No signals found")
            return BacktestMetrics(initial_capital=self.trade_simulator.config.initial_capital)
        
        # Filter signals with targets and confidence
        valid_signals = []
        for s in all_signals:
            signal_data = s.get('signal', {})
            confidence = signal_data.get('confidence', 0)
            
            # Check for targets (at root or in signal)
            targets = s.get('targets') or signal_data.get('targets')
            
            if confidence >= min_confidence and targets:
                valid_signals.append({
                    'timestamp': s.get('timestamp', ''),
                    'price': s.get('price', 0),
                    'signal': signal_data,
                    'targets': targets,
                    'validation': s.get('validation', {})
                })
        
        print(f"   Valid signals (conf >= {min_confidence}%): {len(valid_signals)}")
        
        if not valid_signals:
            print("âŒ No valid signals after filtering")
            return BacktestMetrics(initial_capital=self.trade_simulator.config.initial_capital)
        
        # Get date range
        first_signal = valid_signals[0]
        last_signal = valid_signals[-1]
        
        # Parse timestamps
        first_ts = first_signal['timestamp']
        last_ts = last_signal['timestamp']
        
        if isinstance(first_ts, str):
            first_date = first_ts[:10]
            last_date = last_ts[:10]
        else:
            first_date = datetime.fromtimestamp(first_ts / 1000, tz=timezone.utc).strftime("%Y-%m-%d")
            last_date = datetime.fromtimestamp(last_ts / 1000, tz=timezone.utc).strftime("%Y-%m-%d")
        
        print(f"   Period: {first_date} â†’ {last_date}")
        
        # Step 2: Fetch historical data
        print("\n" + "-" * 40)
        print("STEP 2: Fetching Price Data")
        print("-" * 40)
        
        ohlcv = self.data_provider.fetch_ohlcv(
            symbol="BTC/USDT:USDT",
            timeframe="1h",
            start_date=first_date,
            end_date=last_date
        )
        
        if not ohlcv:
            print("âŒ Failed to fetch price data")
            return BacktestMetrics(initial_capital=self.trade_simulator.config.initial_capital)
        
        # Step 3: Simulate trades
        print("\n" + "-" * 40)
        print("STEP 3: Simulating Trades")
        print("-" * 40)
        
        self.trade_simulator.reset()
        
        # Count by type
        by_type = {}
        
        for i, signal in enumerate(valid_signals):
            signal_data = signal['signal']
            targets = signal['targets']
            
            direction = signal_data.get('direction', 'NEUTRAL')
            signal_type = signal_data.get('type', 'UNKNOWN')
            confidence = signal_data.get('confidence', 0)
            
            # Skip if no clear direction
            if direction not in ['LONG', 'SHORT', 'BULLISH', 'BEARISH']:
                # Try to infer from targets
                tp1 = targets.get('tp1', 0)
                price = signal.get('price', 0)
                if tp1 > price:
                    direction = 'LONG'
                elif tp1 < price:
                    direction = 'SHORT'
                else:
                    continue
            
            # Normalize direction
            if direction == 'BULLISH':
                direction = 'LONG'
            elif direction == 'BEARISH':
                direction = 'SHORT'
            
            # Parse timestamp first
            ts = signal['timestamp']
            if isinstance(ts, str):
                entry_ts = int(datetime.fromisoformat(ts.replace('Z', '+00:00')).timestamp() * 1000)
            else:
                entry_ts = ts

            # Get candles before entry for analysis
            entry_idx = next((i for i, c in enumerate(ohlcv) if c['timestamp'] >= entry_ts), None)
            
            if entry_idx is None:
                continue

            # Prior candles for analysis (last 24h)
            recent_candles = ohlcv[max(0, entry_idx-24):entry_idx]
            
            # --- R&D: SMART ENTRY ---
            # Simulate Smart Entry using Structure (since we don't have historical liq zones)
            smart_entry = self.smart_entry_analyzer.analyze(
                direction=direction,
                current_price=signal['price'],
                original_tp1=targets.get('tp1', 0),
                original_tp2=targets.get('tp2', 0),
                original_sl=targets.get('sl', 0),
                candles=recent_candles
            )
            
            actual_entry_price = signal['price']
            actual_entry_ts = entry_ts
            
            # Logic for WAIT_DIP / LIMIT_ORDER
            if smart_entry.strategy in [EntryStrategy.WAIT_FOR_DIP, EntryStrategy.LIMIT_ORDER]:
                # Look ahead to see if we hit the entry price
                timeout_candles = 4 # Default 4h timeout
                future_candles = ohlcv[entry_idx:entry_idx+timeout_candles]
                
                entry_hit = False
                for fc in future_candles:
                   if direction == 'LONG':
                       if fc['low'] <= smart_entry.optimal_entry:
                           actual_entry_price = smart_entry.optimal_entry
                           actual_entry_ts = fc['timestamp']
                           entry_hit = True
                           break
                   else:
                       if fc['high'] >= smart_entry.optimal_entry:
                           actual_entry_price = smart_entry.optimal_entry
                           actual_entry_ts = fc['timestamp']
                           entry_hit = True
                           break
                
                if not entry_hit:
                    # Trade MISSED due to being too greedy
                    # print(f"   âš ï¸ Trade {signal_type} skipped: Entry {smart_entry.optimal_entry} not reached")
                    continue
            
            # --- R&D: ADAPTIVE LEVERAGE ---
            # Calculate volatility (simple Avg High-Low / Open)
            volatility = 1.0
            if recent_candles:
                ranges = [(c['high'] - c['low']) / c['open'] * 100 for c in recent_candles]
                volatility = sum(ranges) / len(ranges)
            
            leverage_rec = self.adaptive_leverage.calculate(
                entry_price=actual_entry_price,
                tp1_price=targets.get('tp1', 0),
                sl_price=targets.get('sl', 0),
                direction=direction,
                momentum_score=50, # Default, we don't have historical momentum yet
                volatility_pct=volatility,
                capital=self.trade_simulator.current_capital
            )
            
            # Count by type
            by_type[signal_type] = by_type.get(signal_type, 0) + 1
            
            # Open trade
            trade = self.trade_simulator.open_trade(
                signal_timestamp=actual_entry_ts,
                entry_price=actual_entry_price,
                direction=direction,
                signal_type=signal_type,
                confidence=confidence,
                tp1=targets.get('tp1', 0),
                tp2=targets.get('tp2', 0),
                sl=targets.get('sl', 0),
                volatility_pct=volatility
            )
            # Override leverage with adaptive one
            trade.leverage = leverage_rec.recommended_leverage
            
            # Check exit on price data
            trade = self.trade_simulator.check_trade_exit(trade, ohlcv)
        
        # Print signal type distribution
        print(f"   Signals processed by type:")
        for t, count in sorted(by_type.items(), key=lambda x: -x[1]):
            print(f"   - {t}: {count}")
        
        closed_trades = self.trade_simulator.get_closed_trades()
        print(f"\n   Closed trades: {len(closed_trades)}")
        
        # Step 4: Calculate metrics
        print("\n" + "-" * 40)
        print("STEP 4: Calculating Metrics")
        print("-" * 40)
        
        metrics = self.metrics_calculator.calculate(closed_trades)
        
        # Print report
        report = self.metrics_calculator.format_report(metrics)
        print("\n" + report)
        
        # Compare with Gist validation
        self._compare_with_gist_validation(valid_signals, closed_trades)
        
        # Save results
        self._save_results(metrics, valid_signals, closed_trades)
        
        return metrics
    
    def _compare_with_gist_validation(self, signals: List[Dict], trades: List):
        """Compare our simulation with Gist validation"""
        print("\n" + "-" * 40)
        print("COMPARISON: Simulator vs Gist Validation")
        print("-" * 40)
        
        gist_wins = 0
        gist_losses = 0
        gist_expired = 0
        
        for signal in signals:
            validation = signal.get('validation', {})
            status = validation.get('status', 'PENDING')
            
            if status == 'WIN':
                gist_wins += 1
            elif status == 'LOSS':
                gist_losses += 1
            elif status == 'EXPIRED':
                gist_expired += 1
        
        gist_total = gist_wins + gist_losses
        gist_winrate = (gist_wins / gist_total * 100) if gist_total > 0 else 0
        
        sim_wins = len([t for t in trades if t.status.value == 'WIN'])
        sim_losses = len([t for t in trades if t.status.value == 'LOSS'])
        sim_total = sim_wins + sim_losses
        sim_winrate = (sim_wins / sim_total * 100) if sim_total > 0 else 0
        
        print(f"\n   Gist Validation:    {gist_winrate:.1f}% WR ({gist_wins}W/{gist_losses}L, {gist_expired} expired)")
        print(f"   Simulator:          {sim_winrate:.1f}% WR ({sim_wins}W/{sim_losses}L)")
        print(f"\n   Note: Differences may be due to slippage/fees modeling")
    
    def _save_results(self, metrics: BacktestMetrics, signals: List[Dict], trades: List):
        """Save results to file"""
        results_dir = "backtest/results"
        os.makedirs(results_dir, exist_ok=True)
        
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"historical_backtest_{timestamp}.json"
        filepath = os.path.join(results_dir, filename)
        
        # Add open trades
        open_trades = [t for t in self.trade_simulator.trades if t.status.value == 'OPEN']
        # We don't need to extend trades list as self.trade_simulator.trades contains ALL trades
        # But `closed_trades` passed to this function only contains closed ones.
        # So we should reconstruct the full list or just iterate over self.trade_simulator.trades
        
        # Better approach: Use all trades from simulator
        all_trades = self.trade_simulator.trades
        
        trades_data = []
        for t in all_trades:
            entry_dt = datetime.fromtimestamp(t.entry_timestamp / 1000, tz=timezone.utc)
            exit_dt = datetime.fromtimestamp(t.exit_timestamp / 1000, tz=timezone.utc) if t.exit_timestamp else None

            trades_data.append({
                "id": t.id,
                "signal_type": t.signal_type,
                "direction": t.direction,
                "entry_price": t.entry_price,
                "entry_time": entry_dt.strftime("%Y-%m-%d %H:%M:%S"),
                "exit_price": t.exit_price,
                "exit_time": exit_dt.strftime("%Y-%m-%d %H:%M:%S") if exit_dt else None,
                "pnl_usdt": t.pnl_usdt,
                "pnl_pct": t.pnl_pct,
                "status": t.status.value,
                "exit_reason": t.exit_reason,
                "duration_hours": t.time_to_exit_hours
            })
        
        results = {
            "meta": {
                "type": "historical_signals",
                "timestamp": timestamp,
                "source": "gist",
                "signals_count": len(signals)
            },
            "summary": {
                "total_trades": metrics.total_trades,
                "winrate": metrics.winrate_pct,
                "total_pnl_usdt": metrics.total_pnl_usdt,
                "total_pnl_pct": metrics.total_pnl_pct,
                "profit_factor": metrics.profit_factor,
                "sharpe_ratio": metrics.sharpe_ratio,
                "max_drawdown_pct": metrics.max_drawdown_pct,
                "expectancy": metrics.expectancy
            },
            "by_signal_type": metrics.by_signal_type,
            "trades": trades_data
        }
        
        with open(filepath, 'w') as f:
            json.dump(results, f, indent=2)
        
        print(f"\nðŸ’¾ Results saved to: {filepath}")


def main():
    """Run historical signal backtest"""
    import argparse
    
    parser = argparse.ArgumentParser(description="Backtest using historical Gist signals")
    parser.add_argument("--capital", type=float, default=10000, help="Initial capital")
    parser.add_argument("--leverage", type=int, default=23, help="Leverage")
    parser.add_argument("--confidence", type=float, default=65, help="Min confidence")
    
    args = parser.parse_args()
    
    backtester = HistoricalSignalBacktester(
        initial_capital=args.capital,
        leverage=args.leverage
    )
    
    metrics = backtester.run(min_confidence=args.confidence)
    
    return metrics


if __name__ == "__main__":
    main()

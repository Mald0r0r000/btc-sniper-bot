"""
Historical Signal Backtester
Uses real signals from the Gist to run backtests with the trade simulator
"""

import sys
import os
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

import requests
import json
from datetime import datetime, timezone
from typing import Dict, List, Optional

from backtest.data_provider import DataProvider
from backtest.trade_simulator import TradeSimulator, SimulatorConfig
from backtest.metrics import MetricsCalculator, BacktestMetrics

from smart_entry import SmartEntryAnalyzer, EntryStrategy
from adaptive_leverage import AdaptiveLeverageCalculator
from momentum_analyzer import MomentumAnalyzer, MomentumStrength


class HistoricalSignalBacktester:
    """
    Backtest using real signals stored in the GitHub Gist.
    This uses the actual signals generated by DecisionEngineV2 in production.
    """
    
    def __init__(
        self,
        gist_id: str = "b9289f1d093ddfdf94ed0b75eb8e0111",
        initial_capital: float = 10000.0,
        leverage: int = 23,
        position_size_pct: float = 10.0
    ):
        self.gist_id = gist_id
        self.data_provider = DataProvider()
        
        config = SimulatorConfig(
            initial_capital=initial_capital,
            leverage=leverage,
            position_size_pct=position_size_pct
        )
        self.trade_simulator = TradeSimulator(config)
        self.metrics_calculator = MetricsCalculator(initial_capital=initial_capital)
        
        # R&D Modules
        self.smart_entry_analyzer = SmartEntryAnalyzer()
        self.adaptive_leverage = AdaptiveLeverageCalculator()
        self.momentum_analyzer = MomentumAnalyzer()
        
    def fetch_signals_from_gist(self) -> List[Dict]:
        """Fetch signals from GitHub Gist"""
        print("\nðŸ“¡ Fetching signals from Gist...")
        
        try:
            url = f"https://api.github.com/gists/{self.gist_id}"
            response = requests.get(url, timeout=30)
            response.raise_for_status()
            
            gist_data = response.json()
            files = gist_data.get('files', {})
            
            signals = []
            if 'btc_signals_history.json' in files:
                content = json.loads(files['btc_signals_history.json']['content'])
                signals = content.get('signals', [])
            
            print(f"   âœ… Fetched {len(signals)} signals")
            return signals
            
        except Exception as e:
            print(f"   âŒ Error fetching Gist: {e}")
            return []
    
    def run(self, min_confidence: float = 65.0) -> BacktestMetrics:
        """
        Run backtest using historical signals from Gist.
        
        Args:
            min_confidence: Minimum confidence threshold to include signals
            
        Returns:
            BacktestMetrics with results
        """
        print("\n" + "=" * 65)
        print("       BACKTEST WITH REAL HISTORICAL SIGNALS")
        print("=" * 65)
        
        print(f"\nðŸ’° Initial Capital: ${self.trade_simulator.config.initial_capital:,.2f}")
        print(f"âš¡ Leverage: {self.trade_simulator.config.leverage}x")
        print(f"ðŸŽ¯ Min Confidence: {min_confidence}%")
        
        # Step 1: Fetch signals from Gist
        print("\n" + "-" * 40)
        print("STEP 1: Loading Historical Signals")
        print("-" * 40)
        
        all_signals = self.fetch_signals_from_gist()
        
        if not all_signals:
            print("âŒ No signals found")
            return BacktestMetrics(initial_capital=self.trade_simulator.config.initial_capital)
        
        # Filter signals with targets and confidence
        valid_signals = []
        for s in all_signals:
            signal_data = s.get('signal', {})
            confidence = signal_data.get('confidence', 0)
            
            # Check for targets (at root or in signal)
            targets = s.get('targets') or signal_data.get('targets')
            
            if confidence >= min_confidence and targets:
                valid_signals.append({
                    'timestamp': s.get('timestamp', ''),
                    'price': s.get('price', 0),
                    'signal': signal_data,
                    'targets': targets,
                    'validation': s.get('validation', {})
                })
        
        print(f"   Valid signals (conf >= {min_confidence}%): {len(valid_signals)}")
        
        if not valid_signals:
            print("âŒ No valid signals after filtering")
            return BacktestMetrics(initial_capital=self.trade_simulator.config.initial_capital)
        
        # Get date range
        first_signal = valid_signals[0]
        last_signal = valid_signals[-1]
        
        # Parse timestamps
        first_ts = first_signal['timestamp']
        last_ts = last_signal['timestamp']
        
        if isinstance(first_ts, str):
            first_date = first_ts[:10]
            last_date = last_ts[:10]
        else:
            first_date = datetime.fromtimestamp(first_ts / 1000, tz=timezone.utc).strftime("%Y-%m-%d")
            last_date = datetime.fromtimestamp(last_ts / 1000, tz=timezone.utc).strftime("%Y-%m-%d")
        
        print(f"   Period: {first_date} â†’ {last_date}")
        
        # Step 2: Fetch historical data
        print("\n" + "-" * 40)
        print("STEP 2: Fetching Price Data")
        # Step 2: Fetch historical data
        print("\n" + "-" * 40)
        print("STEP 2: Fetching Price Data (1h & 5m)")
        print("-" * 40)
        
        # Fetch 1h for general trend and 5m for precision entry/exit
        multi_tf_data = self.data_provider.fetch_multi_timeframe(
            symbol="BTC/USDT:USDT",
            timeframes=["1h", "5m"],
            start_date=first_date,
            end_date=last_date
        )
        
        ohlcv_1h = multi_tf_data.get("1h", [])
        ohlcv_5m = multi_tf_data.get("5m", [])
        
        if not ohlcv_1h or not ohlcv_5m:
            print("âŒ Failed to fetch price data")
            return BacktestMetrics(initial_capital=self.trade_simulator.config.initial_capital)
        
        # Step 3: Simulate trades
        print("\n" + "-" * 40)
        print("STEP 3: Simulating Trades")
        print("-" * 40)
        
        self.trade_simulator.reset()
        
        # Count by type
        by_type = {}
        trade_snapshots = []
        
        for i, signal in enumerate(valid_signals):
            signal_data = signal['signal']
            targets = signal['targets']
            
            direction = signal_data.get('direction', 'NEUTRAL')
            signal_type = signal_data.get('type', 'UNKNOWN')
            confidence = signal_data.get('confidence', 0)
            
            # Skip if no clear direction
            if direction not in ['LONG', 'SHORT', 'BULLISH', 'BEARISH']:
                # Try to infer from targets
                tp1 = targets.get('tp1', 0)
                price = signal.get('price', 0)
                if tp1 > price:
                    direction = 'LONG'
                elif tp1 < price:
                    direction = 'SHORT'
                else:
                    continue
            
            # Normalize direction
            if direction == 'BULLISH':
                direction = 'LONG'
            elif direction == 'BEARISH':
                direction = 'SHORT'
            
            # Parse timestamp first
            ts = signal['timestamp']
            if isinstance(ts, str):
                entry_ts = int(datetime.fromisoformat(ts.replace('Z', '+00:00')).timestamp() * 1000)
            else:
                entry_ts = ts
                
            # --- PREPARE DATA ---
            # Get index in 1h data
            entry_idx_1h = next((i for i, c in enumerate(ohlcv_1h) if c['timestamp'] >= entry_ts), None)
            
            # Get index in 5m data (for precision & structure)
            entry_idx_5m = next((i for i, c in enumerate(ohlcv_5m) if c['timestamp'] >= entry_ts), None)
            
            if entry_idx_1h is None or entry_idx_5m is None:
                continue

            # Prior candles for analysis
            candles_1h_recent = ohlcv_1h[max(0, entry_idx_1h-50):entry_idx_1h]
            candles_5m_recent = ohlcv_5m[max(0, entry_idx_5m-200):entry_idx_5m]
            
            # --- R&D: IMPLICIT MOMENTUM & SCALPING ---
            # 1. Calculate Momentum Score
            momentum = self.momentum_analyzer.analyze(
                candles=candles_1h_recent, # Use 1H for overall trend/volume momentum
                direction_hint=direction
            )
            
            tp1 = targets.get('tp1', 0)
            tp2 = targets.get('tp2', 0)
            sl = targets.get('sl', 0)
            
            # 2. Check for Weak Momentum -> Scalp Mode
            is_scalp_mode = False
            # HYBRID STRATEGY: Only Scalp on FADE signals (Mean Reversion)
            if momentum.strength.value == 'WEAK' and 'FADE' in signal_type: 
                # Use Fractal Structure on 5m/15m for closer targets
                fractal_targets = self.momentum_analyzer.get_fractal_targets(
                    candles_5m=candles_5m_recent,
                    candles_1h=candles_1h_recent,
                    candles_4h=[], # Not using 4h here
                    direction=direction,
                    momentum_strength=momentum.strength,
                    current_price=signal['price']
                )
                
                if fractal_targets:
                    # Validate targets (must be better than entry)
                    new_tp1 = fractal_targets.get('tp1', tp1)
                    new_sl = fractal_targets.get('sl', sl)
                    
                    valid_scalp = False
                    if direction == 'LONG' and new_tp1 > signal['price'] and new_sl < signal['price']:
                         valid_scalp = True
                    elif direction == 'SHORT' and new_tp1 < signal['price'] and new_sl > signal['price']:
                         valid_scalp = True
                         
                    if valid_scalp:
                        tp1 = new_tp1
                        tp2 = fractal_targets.get('tp2', tp2)
                        sl = new_sl
                        is_scalp_mode = True
                        # print(f"   ðŸŒ SCALP MODE ({signal_type}): TP {targets.get('tp1')} -> {tp1}")
            
            
            # --- R&D: SMART ENTRY (Optimized) ---
            # Simulate Smart Entry using Structure (Reverted to 1h for robustness/selectivity)
            
            # EXPERIMENT: Force specific params for BREAKOUT signals to catch RETESTS
            is_breakout = 'BREAKOUT' in signal_type
            if is_breakout:
                # Save original params
                orig_min_imp = self.smart_entry_analyzer.min_improvement_pct
                orig_max_wait = self.smart_entry_analyzer.max_wait_distance_pct
                
                # Tune for Breakout retest: Be very greedy for better entry (retest)
                # We want to catch the dip back to the breakout level or a liq zone
                self.smart_entry_analyzer.min_improvement_pct = 0.01  # Wait for ANY improvement
                self.smart_entry_analyzer.max_wait_distance_pct = 5.0 # Allow deeper retest
            
            smart_entry = self.smart_entry_analyzer.analyze(
                direction=direction,
                current_price=signal['price'],
                original_tp1=tp1,
                original_tp2=tp2,
                original_sl=sl,
                candles=candles_1h_recent # Back to 1h for robust structure analysis
            )
            
            if is_breakout:
                # Restore original params
                self.smart_entry_analyzer.min_improvement_pct = orig_min_imp
                self.smart_entry_analyzer.max_wait_distance_pct = orig_max_wait
                
                # Log decision for ALL Breakouts
                print(f"   ðŸ§ª BREAKOUT OPTIMIZATION: {signal_type} -> {smart_entry.strategy.value} @ ${smart_entry.optimal_entry:,.0f} (was ${signal['price']:,.0f})")
            
            actual_entry_price = signal['price']
            actual_entry_ts = entry_ts
            
            # Logic for WAIT_DIP / LIMIT_ORDER
            if smart_entry.strategy in [EntryStrategy.WAIT_FOR_DIP, EntryStrategy.LIMIT_ORDER]:
                # Look ahead 4h using 5m candles for precision execution check
                timeout_candles = 4 * 12 # 4 hours * 12 (5m candles)
                future_candles = ohlcv_5m[entry_idx_5m:entry_idx_5m+timeout_candles]
                
                entry_hit = False
                for fc in future_candles:
                   if direction == 'LONG':
                       if fc['low'] <= smart_entry.optimal_entry:
                           actual_entry_price = smart_entry.optimal_entry
                           actual_entry_ts = fc['timestamp']
                           entry_hit = True
                           break
                   else:
                       if fc['high'] >= smart_entry.optimal_entry:
                           actual_entry_price = smart_entry.optimal_entry
                           actual_entry_ts = fc['timestamp']
                           entry_hit = True
                           break
                
                if not entry_hit:
                    continue
            
            
            # --- R&D: ADAPTIVE LEVERAGE ---
            # Calculate volatility on 5m for precision
            volatility = 1.0
            if candles_5m_recent:
                # Annualized volatility or simple high-low range? Using Avg Range %
                ranges = [(c['high'] - c['low']) / c['open'] * 100 for c in candles_5m_recent[-12:]] # Last hour
                volatility = sum(ranges) / len(ranges)
            
            leverage_rec = self.adaptive_leverage.calculate(
                entry_price=actual_entry_price,
                tp1_price=tp1,
                sl_price=sl,
                direction=direction,
                momentum_score=momentum.score, # Use real calculated momentum
                volatility_pct=volatility,
                capital=self.trade_simulator.current_capital
            )
            
            # Count by type
            by_type[signal_type] = by_type.get(signal_type, 0) + 1
            
            # Open trade
            trade = self.trade_simulator.open_trade(
                signal_timestamp=actual_entry_ts,
                entry_price=actual_entry_price,
                direction=direction,
                signal_type=signal_type,
                confidence=confidence,
                tp1=tp1,
                tp2=tp2,
                sl=sl,
                volatility_pct=volatility
            )
            # Override leverage with adaptive one
            trade.leverage = leverage_rec.recommended_leverage
            # Tag as scalp if applicable
            if is_scalp_mode:
                trade.signal_type = f"{signal_type}_SCALP"
            
            # Check exit on price data (Use 5m for precision exit check)
            # Find index in 5m for exit check
            trade = self.trade_simulator.check_trade_exit(trade, ohlcv_5m) # Using 5m for simulation precision
            
            # --- COLLECT RETRO-DATA FOR PATTERN DISCOVERY ---
            # Now that trade is closed (simulated), let's snapshot the conditions
            trade_snapshots.append({
                'id': trade.id,
                'result': trade.status.value,  # WIN / LOSS
                'pnl_pct': trade.pnl_pct,
                'signal_type': signal_type,
                'momentum_score': momentum.score,
                'momentum_strength': momentum.strength.value,
                'smart_entry_strategy': smart_entry.strategy.value,
                'volatility': volatility,
                'direction': direction
            })
        
        # Print signal type distribution
        print(f"   Signals processed by type:")
        for t, count in sorted(by_type.items(), key=lambda x: -x[1]):
            print(f"   - {t}: {count}")
        
        closed_trades = self.trade_simulator.get_closed_trades()
        print(f"\n   Closed trades: {len(closed_trades)}")
        
        # Step 4: Calculate metrics
        print("\n" + "-" * 40)
        print("STEP 4: Calculating Metrics")
        print("-" * 40)
        
        metrics = self.metrics_calculator.calculate(closed_trades)
        
        # Print report
        report = self.metrics_calculator.format_report(metrics)
        print("\n" + report)
        
        # Compare with Gist validation
        self._compare_with_gist_validation(valid_signals, closed_trades)
        
        # --- PATTERN DISCOVERY ---
        self._analyze_patterns(trade_snapshots)
        
        # Save results
        self._save_results(metrics, valid_signals, closed_trades)
        
        return metrics
    
    def _compare_with_gist_validation(self, signals: List[Dict], trades: List):
        """Compare our simulation with Gist validation"""
        print("\n" + "-" * 40)
        print("COMPARISON: Simulator vs Gist Validation")
        print("-" * 40)
        
        gist_wins = 0
        gist_losses = 0
        gist_expired = 0
        
        for signal in signals:
            validation = signal.get('validation', {})
            status = validation.get('status', 'PENDING')
            
            if status == 'WIN':
                gist_wins += 1
            elif status == 'LOSS':
                gist_losses += 1
            elif status == 'EXPIRED':
                gist_expired += 1
        
        gist_total = gist_wins + gist_losses
        gist_winrate = (gist_wins / gist_total * 100) if gist_total > 0 else 0
        
        sim_wins = len([t for t in trades if t.status.value == 'WIN'])
        sim_losses = len([t for t in trades if t.status.value == 'LOSS'])
        sim_total = sim_wins + sim_losses
        sim_winrate = (sim_wins / sim_total * 100) if sim_total > 0 else 0
        
        print(f"\n   Gist Validation:    {gist_winrate:.1f}% WR ({gist_wins}W/{gist_losses}L, {gist_expired} expired)")
        print(f"   Simulator:          {sim_winrate:.1f}% WR ({sim_wins}W/{sim_losses}L)")
        print(f"\n   Note: Differences may be due to slippage/fees modeling")
        


    def _analyze_patterns(self, snapshots: List[Dict]):
        """
        Analyze correlation between module scores and trade outcome (Win/Loss).
        """
        print("\n" + "=" * 40)
        print("ðŸ”Ž PATTERN DISCOVERY REPORT (Retro-Analysis)")
        print("=" * 40)
        
        wins = [s for s in snapshots if s['result'] == 'WIN']
        losses = [s for s in snapshots if s['result'] == 'LOSS']
        
        if not wins and not losses:
            print("   No data to analyze.")
            return

        print(f"   Analyzing {len(snapshots)} trades ({len(wins)} Wins, {len(losses)} Losses)...")
        
        # Helper to get avg
        def get_avg(data, key):
            values = [d[key] for d in data if d.get(key) is not None]
            return sum(values)/len(values) if values else 0
            
        # 1. Momentum Analysis
        win_mom = get_avg(wins, 'momentum_score')
        loss_mom = get_avg(losses, 'momentum_score')
        print(f"\n   1. MOMENTUM SCORE")
        print(f"      - Avg in WINS:   {win_mom:.1f}")
        print(f"      - Avg in LOSSES: {loss_mom:.1f}")
        print(f"      - Delta:         {win_mom - loss_mom:+.1f} (Positive = Momentum predictors success)")
        
        # 2. Volatility Analysis
        win_vol = get_avg(wins, 'volatility')
        loss_vol = get_avg(losses, 'volatility')
        print(f"\n   2. VOLATILITY (%)")
        print(f"      - Avg in WINS:   {win_vol:.2f}%")
        print(f"      - Avg in LOSSES: {loss_vol:.2f}%")
        
        # 3. Smart Entry Strategy Performance
        print(f"\n   3. SMART ENTRY STRATEGY")
        strategies = set(s['smart_entry_strategy'] for s in snapshots)
        for strat in strategies:
            strat_trades = [s for s in snapshots if s['smart_entry_strategy'] == strat]
            strat_wins = [s for s in strat_trades if s['result'] == 'WIN']
            wr = len(strat_wins) / len(strat_trades) * 100 if strat_trades else 0
            print(f"      - {strat}: {len(strat_trades)} trades, {wr:.1f}% Winrate")

        print("\n   ðŸ’¡ INSIGHTS:")
        if abs(win_mom - loss_mom) > 5:
            print("   -> Momentum seems to be a significant predictor.")
        else:
            print("   -> Momentum impact is neutral in this sample.")
            
        print("=" * 40)

    def _save_results(self, metrics: BacktestMetrics, signals: List[Dict], trades: List):
        """Save results to file"""
        results_dir = "backtest/results"
        os.makedirs(results_dir, exist_ok=True)
        
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"historical_backtest_{timestamp}.json"
        filepath = os.path.join(results_dir, filename)
        
        # Add open trades
        open_trades = [t for t in self.trade_simulator.trades if t.status.value == 'OPEN']
        # We don't need to extend trades list as self.trade_simulator.trades contains ALL trades
        # But `closed_trades` passed to this function only contains closed ones.
        # So we should reconstruct the full list or just iterate over self.trade_simulator.trades
        
        # Better approach: Use all trades from simulator
        all_trades = self.trade_simulator.trades
        
        trades_data = []
        for t in all_trades:
            entry_dt = datetime.fromtimestamp(t.entry_timestamp / 1000, tz=timezone.utc)
            exit_dt = datetime.fromtimestamp(t.exit_timestamp / 1000, tz=timezone.utc) if t.exit_timestamp else None

            trades_data.append({
                "id": t.id,
                "signal_type": t.signal_type,
                "direction": t.direction,
                "entry_price": t.entry_price,
                "entry_time": entry_dt.strftime("%Y-%m-%d %H:%M:%S"),
                "exit_price": t.exit_price,
                "exit_time": exit_dt.strftime("%Y-%m-%d %H:%M:%S") if exit_dt else None,
                "pnl_usdt": t.pnl_usdt,
                "pnl_pct": t.pnl_pct,
                "status": t.status.value,
                "exit_reason": t.exit_reason,
                "duration_hours": t.time_to_exit_hours
            })
        
        results = {
            "meta": {
                "type": "historical_signals",
                "timestamp": timestamp,
                "source": "gist",
                "signals_count": len(signals)
            },
            "summary": {
                "total_trades": metrics.total_trades,
                "winrate": metrics.winrate_pct,
                "total_pnl_usdt": metrics.total_pnl_usdt,
                "total_pnl_pct": metrics.total_pnl_pct,
                "profit_factor": metrics.profit_factor,
                "sharpe_ratio": metrics.sharpe_ratio,
                "max_drawdown_pct": metrics.max_drawdown_pct,
                "expectancy": metrics.expectancy
            },
            "by_signal_type": metrics.by_signal_type,
            "trades": trades_data
        }
        
        with open(filepath, 'w') as f:
            json.dump(results, f, indent=2)
        
        print(f"\nðŸ’¾ Results saved to: {filepath}")


def main():
    """Run historical signal backtest"""
    import argparse
    
    parser = argparse.ArgumentParser(description="Backtest using historical Gist signals")
    parser.add_argument("--capital", type=float, default=10000, help="Initial capital")
    parser.add_argument("--leverage", type=int, default=23, help="Leverage")
    parser.add_argument("--confidence", type=float, default=65, help="Min confidence")
    
    args = parser.parse_args()
    
    backtester = HistoricalSignalBacktester(
        initial_capital=args.capital,
        leverage=args.leverage
    )
    
    metrics = backtester.run(min_confidence=args.confidence)
    
    return metrics


if __name__ == "__main__":
    main()
